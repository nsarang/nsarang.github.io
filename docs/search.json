[
  {
    "objectID": "project/index.html",
    "href": "project/index.html",
    "title": "Projects",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nDCGAN on MNIST\n\n\nA keras implementation of DC-GAN trained on MNIST dataset.\n\n\n\nJun 12, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nD3 Force Layout - Biological Networks\n\n\nAn interactive graph visualization of protein-protein interaction networks.\n\n\n\nSep 17, 2017\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Musings from My Corner of the World",
    "section": "",
    "text": "Multi-Layer LSTM from Scratch using NumPy\n\n\n\n\n\n\nml\n\n\nanalysis\n\n\n\nIn this post, we will implement a multi-layer LSTM model from scratch in pure NumPy, and train it on the Shakespeare dataset. Weâ€™ll also implement the AdamW optimizer and the necessary data modules.\n\n\n\n\n\nJun 15, 2024\n\n\nNima Sarang\n\n\n5 min\n\n\n\n\n\n\nNo matching items\n\nReuseCC BY-SA 4.0"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Nima Sarang",
    "section": "",
    "text": "Welcome to my personal website! I share my work, thoughts, and experiences here.\nMy drive is to use data science and machine learning to solve real-world problems, so most of the content youâ€™ll find here is in that vein.\nIâ€™m always looking for new opportunities to learn and grow, so feel free to reach out if youâ€™d like to collaborate or chat!\nLearn more about me â†’"
  },
  {
    "objectID": "publication/2023-07-01-tractable-reinforcement-learning/index.html",
    "href": "publication/2023-07-01-tractable-reinforcement-learning/index.html",
    "title": "Tractable large-scale deep reinforcement learning",
    "section": "",
    "text": "Reinforcement learning (RL) has emerged as one of the most promising and powerful techniques in deep learning. The training of intelligent agents requires a myriad of training examples which imposes a substantial computational cost. Consequently, RL is seldom applied to real-world problems and historically has been limited to computer vision tasks, similar to supervised learning. This work proposes an RL framework for complex, partially observable, large-scale environments. We introduce novel techniques for tractable training on commodity GPUs, and significantly reduce computational costs. Furthermore, we present a self-supervised loss that improves the learning stability in applications with a long-time horizon, shortening the training time. We demonstrate the effectiveness of the proposed solution on the application of road extraction from high-resolution satellite images. We present experiments on satellite images of fifteen cities that demonstrate comparable performance to state-of-the-art methods. To the best of our knowledge, this is the first time RL has been applied for extracting road networks. The code is publicly available at https://github.com/nsarang/road-extraction-rl."
  },
  {
    "objectID": "publication/2023-07-01-tractable-reinforcement-learning/index.html#abstract",
    "href": "publication/2023-07-01-tractable-reinforcement-learning/index.html#abstract",
    "title": "Tractable large-scale deep reinforcement learning",
    "section": "",
    "text": "Reinforcement learning (RL) has emerged as one of the most promising and powerful techniques in deep learning. The training of intelligent agents requires a myriad of training examples which imposes a substantial computational cost. Consequently, RL is seldom applied to real-world problems and historically has been limited to computer vision tasks, similar to supervised learning. This work proposes an RL framework for complex, partially observable, large-scale environments. We introduce novel techniques for tractable training on commodity GPUs, and significantly reduce computational costs. Furthermore, we present a self-supervised loss that improves the learning stability in applications with a long-time horizon, shortening the training time. We demonstrate the effectiveness of the proposed solution on the application of road extraction from high-resolution satellite images. We present experiments on satellite images of fifteen cities that demonstrate comparable performance to state-of-the-art methods. To the best of our knowledge, this is the first time RL has been applied for extracting road networks. The code is publicly available at https://github.com/nsarang/road-extraction-rl."
  },
  {
    "objectID": "about/index.html",
    "href": "about/index.html",
    "title": "About Me",
    "section": "",
    "text": "CV\n  \n  \n    \n     GitHub\n  \n  \n    \n     LinkedIn\n  \n  \n    \n     Twitter\n  \n\n  \n  \n\nðŸ‘‹ Hey there!\n\n\nIâ€™m Nima Sarang. Iâ€™m a Machine Learning Scientist at Expedia Group. I build and manage machine learning models for Search Engine Marketing (SEM), for Expedia Groupâ€™s global brands, like Expedia, Hotels.com and Vrbo.\nIâ€™m addicted to learning and sharing knowledge, and am enthusiastic about applying statistical and machine learning techniques to solve real-world problems."
  },
  {
    "objectID": "about/index.html#about-me",
    "href": "about/index.html#about-me",
    "title": "About Me",
    "section": "About Me",
    "text": "About Me\nPrior to working at Expedia Group, I was a Machine Learning Engineer at Divar, where I worked on pricing and computer vision models for the largest e-commerce platform in Iran. I had the joy and fortune of working with a lot of talented people, and learned how to build and deploy machine learning models at scale.\nI completed my masterâ€™s degree in Computer Science at Concordia University, where I was a member of the Immersive & Creative Technologies Lab. I worked on applying deep reinforement learning to satellite imagery data for extracting road networks using controllable agents.\nIâ€™m a passionate about solving problems. In my free time, I often participate in Kaggle-like competitions to learn about applying ML techniques to different problems. I try to keep up with the latest research in the field, and am always looking for ways to improve my skills. One of the reason I started this website is to write about things I discover and share cool stuff.\n\nLetâ€™s do something awesome together!\nIf youâ€™re interested in working with me, please drop me a line at contact@nimasarang.com!"
  },
  {
    "objectID": "blog/2024-06-15-lstm-from-scratch/index.html",
    "href": "blog/2024-06-15-lstm-from-scratch/index.html",
    "title": "Multi-Layer LSTM from Scratch using NumPy",
    "section": "",
    "text": "In this post, I will implement the Long-Short Term Memory (LSTM) model in NumPy. This is to serve as a learning excercise to understand the inner working of the neural network, backpropagation, and the optimization process. I try to strike a balance between readability and efficeincy. So, weâ€™ll be going over the imeplemntation of:\n\nMulti-layer LSTM Model\n\nAdamW Optimizer\n\nDataset and Dataloader\n\nTraining on the Shakespeare dataset\n\nall in NumPy!\nBy the end of this post, should you have a good grasp of how LSTM works on both the forward and backward pass, what is the AdamW optimizer, and how to train a model on a text dataset."
  },
  {
    "objectID": "blog/2024-06-15-lstm-from-scratch/index.html#introduction",
    "href": "blog/2024-06-15-lstm-from-scratch/index.html#introduction",
    "title": "Multi-Layer LSTM from Scratch using NumPy",
    "section": "",
    "text": "In this post, I will implement the Long-Short Term Memory (LSTM) model in NumPy. This is to serve as a learning excercise to understand the inner working of the neural network, backpropagation, and the optimization process. I try to strike a balance between readability and efficeincy. So, weâ€™ll be going over the imeplemntation of:\n\nMulti-layer LSTM Model\n\nAdamW Optimizer\n\nDataset and Dataloader\n\nTraining on the Shakespeare dataset\n\nall in NumPy!\nBy the end of this post, should you have a good grasp of how LSTM works on both the forward and backward pass, what is the AdamW optimizer, and how to train a model on a text dataset."
  },
  {
    "objectID": "blog/2024-06-15-lstm-from-scratch/index.html#multi-layer-lstm",
    "href": "blog/2024-06-15-lstm-from-scratch/index.html#multi-layer-lstm",
    "title": "Multi-Layer LSTM from Scratch using NumPy",
    "section": "Multi-Layer LSTM",
    "text": "Multi-Layer LSTM\nLong Short-Term Memory (LSTM) is a type of recurrent neural network (RNN) architecture specifically designed to handle long-term dependencies in sequential data. It incorporates a memory state, a hidden state, and three gating mechanisms: the input gate, forget gate, and output gate. These gates control the flow of information into, out of, and within the memory and hidden states, allowing the LSTM to selectively remember or forget information at each time step.\nThe memory state in an LSTM acts as a long-term storage unit, allowing the network to retain information over long sequences. The input gate determines how much new information should be stored in the memory state, while the forget gate controls the amount of old information to be discarded. The output gate regulates the flow of information from the memory state and hidden state to the next time step.\n\n\n\nLSTM Architecture [1]\n\n\nThe LSTM cell consists of the following components: \\[\n\\begin{aligned}\nf_t &= \\sigma(W_{if}x_t + b_{if} + W_{hf}h_{t-1} + b_{hf}) \\\\\ni_t &= \\sigma(W_{ii}x_t + b_{ii} + W_{hi}h_{t-1} + b_{hi}) \\\\\no_t &= \\sigma(W_{io}x_t + b_{io} + W_{ho}h_{t-1} + b_{ho}) \\\\\n\\tilde{C}_t &= \\tanh(W_{ic}x_t + b_{ic} + W_{hc}h_{t-1} + b_{hc}) \\\\\nC_t &= f_t \\odot C_{t-1} + i_t \\odot \\tilde{C}_t \\\\\nh_t &= o_t \\odot \\tanh(C_t)\n\\end{aligned}\n\\]\nwhere \\(f_t\\), \\(i_t\\), and \\(o_t\\) are the forget, input, and output gates, respectively. \\(\\tilde{C}_t\\) is the candidate memory state, \\(C_t\\) is the memory state, and \\(h_t\\) is the hidden state at time step \\(t\\). \\(x_t\\) is the input at time step \\(t\\), \\(h_{t-1}\\) is the hidden state at time step \\(t-1\\), and \\(W\\) and \\(b\\) are the weights and biases of each gate.\nA multi-latyer LSTM is simply stacking multiple LSTM cells on top of each other. The output of the previous LSTM cell is fed as input to the next LSTM cell. The hidden state of the last LSTM cell is the input to the classification layer.\n\n\n\nMulti-layer LSTM Example [2]. Each row of the green rectangles represent an LSTM cell.\n\n\nNow letâ€™s get into the implementation, step by step.\n\n&gt; lstm.py\n\n\n\n        \n            \n            \n        \n            \n                \n                    #\n                \n                Import the dependencies.  \nThe activation functions are defined in a separate module\n\n            \n            \n                1import numpy as np\n2from collections import defaultdict\n3from copy import deepcopy\n4from op import sigmoid, tanh, softmax\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                LSTM Classifier\nMulti-layer LSTM classifier for sequence classification tasks.\nIt consists of an embedding layer, multiple LSTM cells, and a classification head.\nThe model is used to process input sequences and generate output logits.\n\n            \n            \n                5class LSTMClassifier:\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \n            \n            \n                 6    def __init__(\n 7        self,\n 8        embed_size,\n 9        hidden_size,\n10        vocab_size,\n11        n_cells=1,\n12        dropout=0,\n13    ) -&gt; None:\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Define internal variables\n\n            \n            \n                14        self.embed_size = embed_size\n15        self.hidden_size = hidden_size\n16        self.vocab_size = vocab_size\n17        self.n_cells = n_cells\n18        self.layers = dict()\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Embedding layer\n\n            \n            \n                19        self.layers[\"embedding\"] = np.empty((vocab_size, embed_size))\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Create LSTM layers\n\n            \n            \n                20        for cell_index in range(n_cells):\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                forget, output, and cell gates\n\n            \n            \n                21            for layer_name in [\"f\", \"o\", \"c\"]:\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                The input size of the first layer is embed_size + hidden_size, since the input is the concatenation of the input features and the previous hidden state. For subsequent layers, the input size is 2 x hidden_size.\n\n            \n            \n                22                linp_sz = hidden_size + (\n23                    embed_size if cell_index == 0 else hidden_size\n24                )\n25                self.layers[f\"W{layer_name}_{cell_index}\"] = (\n26                    np.empty((linp_sz, hidden_size))\n27                )\n28                self.layers[f\"b{layer_name}_{cell_index}\"] = (\n29                    np.empty((hidden_size))\n30                )\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Classification head (projection layer) to generate the output logits\n\n            \n            \n                31        self.layers[\"W_head\"] = np.empty((hidden_size, vocab_size))\n32        self.layers[\"b_head\"] = np.empty((vocab_size))\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Initialize gradients\n\n            \n            \n                33        self.grad = {\n34            k: np.empty_like(v) for k, v in self.layers.items()\n35        }\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Initialize weights\n\n            \n            \n                36        self.init_weights()\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \n            \n            \n                37    @property\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Calculate the total number of parameters in the model.\nThe size property of a numpy array returns the number of elements in the array.\n\n            \n            \n                38    def num_parameters(self):\n39        return sum(l.size for l in self.layers.values())\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Glorot/Xavier initialization\nThe weights are initialized from a uniform distribution in the range \\([-d, d]\\), where\n\\(d = \\sqrt{\\frac{6.0}{(r + c)}}\\), and \\(r\\) and \\(c\\) are the number of rows and columns\nin the weight matrix. This makes the variance of the weights inversely proportional to the\nnumber the units, and helps in preventing the gradients from vanishing or exploding during\ntraining. The biases are initialized to zero.\n\n            \n            \n                40    def init_weights(self):\n41        for name, layer in self.layers.items():\n42            if layer.ndim == 1:\n43                self.layers[name] = np.zeros((layer.shape[0]))\n44            elif layer.ndim == 2:\n45                r, c = layer.shape\n46                d = np.sqrt(6.0 / (r + c))\n47                self.layers[name] = np.random.uniform(-d, d, (r, c))\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Initialize the hidden and cell states for the LSTM layers.\n\n            \n            \n                48    def init_state(self, batch_size):\n49        state = dict()\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                For each LSTM cell, initialize the hidden and cell states to zeros\n\n            \n            \n                50        state[\"h\"] = np.zeros(\n51            (self.n_cells, batch_size, self.hidden_size)\n52        )\n53        state[\"c\"] = np.zeros(\n54            (self.n_cells, batch_size, self.hidden_size)\n55        )\n56        return state\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Forward pass through the LSTM model.\n\ninputs: Input sequences of shape (batch_size, seq_len, features)\nstate: Hidden and cell states of the LSTM layers. If None, initialize the states to zeros.\nteacher_forcing: If True, use inputs as the input at each timestep.\nIf False, inputs is used as the prefix.\ngeneration_length: Length of the generated sequence when teacher_forcing is False.\n\n\n            \n            \n                57    def forward(\n58        self,\n59        inputs,\n60        state=None,\n61        teacher_forcing=True,\n62        generation_length=0,\n63    ):\n64        batch_sz, seq_len = inputs.shape[:2]\n65\n66        if teacher_forcing is True:\n67            assert generation_length == 0\n68\n69        n_timestamps = seq_len + generation_length\n70        activations = defaultdict(lambda: defaultdict(list))\n71        outputs = np.zeros((batch_sz, n_timestamps, self.vocab_size))\n72\n73        if state is None:\n74            state = self.init_state(batch_sz)\n75        else:\n76            state = state.copy()  # make a shallow copy\n77        for k in [\"h\", \"c\"]:\n78            activations[k][-1] = state[k]\n79\n80        for timestep in range(n_timestamps):\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                If teacher forcing is False and the prefix is consumed, use the previous prediction as the input\nfor the next timestep\n\n            \n            \n                81            if teacher_forcing is False and timestep &gt;= 1:\n82                word_indices = np.argmax(\n83                    outputs[:, timestep - 1], axis=1\n84                )\n85            else:\n86                word_indices = inputs[:, timestep]\n87            features = self.layers[\"embedding\"][word_indices]\n88            activations[\"input\"][timestep] = word_indices\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Forward pass through the LSTM cells\n\n            \n            \n                89            for cell_idx in range(self.n_cells):\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Previous cell states\n\n            \n            \n                90                h_prev = state[\"h\"][cell_idx]\n91                c_prev = state[\"c\"][cell_idx]\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Concatenate the input features and the previous hidden state\n\n            \n            \n                92                X = np.concatenate((features, h_prev), axis=-1)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Apply the gates, which are linear operations followed by activation functions\n\n            \n            \n                 93                f = sigmoid(\n 94                    X @ self.layers[f\"Wf_{cell_idx}\"]\n 95                    + self.layers[f\"bf_{cell_idx}\"]\n 96                )\n 97                o = sigmoid(\n 98                    X @ self.layers[f\"Wo_{cell_idx}\"]\n 99                    + self.layers[f\"bo_{cell_idx}\"]\n100                )\n101                c_bar = tanh(\n102                    X @ self.layers[f\"Wc_{cell_idx}\"]\n103                    + self.layers[f\"bc_{cell_idx}\"]\n104                )\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                New cell states\n\n            \n            \n                105                c = f * c_prev + (1 - f) * c_bar\n106                h = o * tanh(c)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Classification head\n\n            \n            \n                107                if cell_idx == self.n_cells - 1:\n108                    logits = (\n109                        h @ self.layers[\"W_head\"]\n110                        + self.layers[\"b_head\"]\n111                    )\n112                    probs = softmax(logits, axis=1)\n113                    outputs[:, timestep] = probs\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Update the state for the next timestep\n\n            \n            \n                114                state[\"c\"][cell_idx] = c\n115                state[\"h\"][cell_idx] = h\n116                features = h\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Save the activations for backpropagation\n\n            \n            \n                117                for k, v in zip(\n118                    [\"x\", \"f\", \"o\", \"c_bar\", \"c\", \"h\"],\n119                    [X, f, o, c_bar, c, h],\n120                ):\n121                    activations[k][timestep].append(v)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \n            \n            \n                122        return outputs, state, activations\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Alias for the forward method, similar to PyTorch's nn.Module.\nThis enables model(inputs) \\(\\equiv\\) model.forward(inputs)\n\n            \n            \n                123    __call__ = forward\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Backward pass to compute the gradients.\n\ngrad: Gradient of the loss with respect to the output of the model, i.e. logits (pre-softmax scores)\nactivations: Activations from the forward pass.\n\n\n            \n            \n                124    def backward(self, grad, activations):\n125        batch_sz, seq_len = grad.shape[:2]\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Intialize the gradients of the next timestep to zeros. This will be updated as we move backward in time.\n\n            \n            \n                126        grad_next = {\n127            k: np.zeros((self.n_cells, batch_sz, self.hidden_size))\n128            for k in [\"h\", \"c\"]\n129        }\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Helper function to compute the gradients of the linear layer.\nThe gradients are computed with respect to the input, weights, and biases respectively.\n\nX: Input to the linear layer\nW: Weights of the linear layer\ndY: Gradient of the loss with respect to the output of the linear layer\n\n\n            \n            \n                130        def _lin_grad(X, W, dY):\n131            return (dY @ W.T, X.T @ dY, dY)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Backpropagation through time\n\n            \n            \n                132        for timestep in reversed(range(seq_len)):\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Classification head\n\n            \n            \n                133            dout_t = grad[:, timestep]\n134            h_t = activations[\"h\"][timestep][-1]\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \\(\\text{logits}_t = h_t \\mathbf{W}_{\\text{head}} + \\mathbf{b}_{\\text{head}}\\)\n\n            \n            \n                135            dh_t, dW_head, db_head = _lin_grad(\n136                X=h_t, W=self.layers[\"W_head\"], dY=dout_t\n137            )\n138            self.grad[f\"W_head\"] += dW_head\n139            self.grad[f\"b_head\"] += np.sum(db_head, axis=0)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Iterate over the LSTM cells in reverse order\n\n            \n            \n                140            for cell_idx in reversed(range(self.n_cells)):\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Get the activations for the current timestep\n\n            \n            \n                141                x, f, o, c_bar, c_t = (\n142                    activations[key][timestep][cell_idx]\n143                    for key in [\"x\", \"f\", \"o\", \"c_bar\", \"c\"]\n144                )\n145                c_p = activations[\"c\"][timestep - 1][cell_idx]\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Gradients flowing from the next timestep. The gradient of the hidden state \\(h_t\\) is the sum of\nthe gradients from the next cell and the next timestep.\n\n            \n            \n                146                dh_t += grad_next[\"h\"][cell_idx]\n147                dc_t = grad_next[\"c\"][cell_idx]\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \\(h_t = o * tanh(c_t)\\)\n\n            \n            \n                148                do = dh_t * tanh(c_t)\n149                dc_t = dh_t * o * tanh(c_t, grad=True)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \\(c_t = f \\times c_p + (1 - f) \\times c_{\\text{bar}}\\)\n\n            \n            \n                150                df = dc_t * (c_p - c_bar)\n151                dc_p = dc_t * f\n152                dc_bar = dc_t * (1 - f)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Pre-activation gradients\n\n            \n            \n                153                dc_bar *= tanh(c_bar, grad=True)\n154                do *= sigmoid(o, grad=True)\n155                df *= sigmoid(f, grad=True)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                f, o, c Gates\nSince all the gates are linear operations, the calculation will be similar\n\n            \n            \n                156                dinp, dh_prev = 0, 0\n157                for gate, doutput in zip(\n158                    [\"f\", \"o\", \"c\"], [df, do, dc_bar]\n159                ):\n160                    dX, dW, db = _lin_grad(\n161                        X=x,\n162                        W=self.layers[f\"W{gate}_{cell_idx}\"],\n163                        dY=doutput,\n164                    )\n165                    self.grad[f\"W{gate}_{cell_idx}\"] += dW\n166                    self.grad[f\"b{gate}_{cell_idx}\"] += np.sum(\n167                        db, axis=0\n168                    )\n169                    dinp_gate, dh_prev_gate = (\n170                        dX[:, : -self.hidden_size],\n171                        dX[:, -self.hidden_size :],\n172                    )\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Accumulate the gradients for the input and the hidden state,\nsince they are shared between the gates\n\n            \n            \n                173                    dinp += dinp_gate\n174                    dh_prev += dh_prev_gate\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Update the gradients for the previous timestep\n\n            \n            \n                175                dh_t = dinp\n176                grad_next[\"c\"][cell_idx] = dc_p\n177                grad_next[\"h\"][cell_idx] = dh_prev\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Embedding layer\n\n            \n            \n                178            word_indices = activations[\"input\"][timestep]\n179            self.grad[\"embedding\"][word_indices] += dinp\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \n            \n            \n                180    @property\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Helper method to serialize the model state, similar to PyTorch's state_dict.\nThe state dictionary contains the model configuration, weights, and gradients.\nIt can be used to save and load the model.\n\n            \n            \n                181    def state_dict(self):\n182        return dict(\n183            config=dict(\n184                embed_size=self.embed_size,\n185                hidden_size=self.hidden_size,\n186                vocab_size=self.vocab_size,\n187                n_cells=self.n_cells,\n188            ),\n189            weights=deepcopy(self.layers),\n190            grad=deepcopy(self.grad),\n191        )\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \n            \n            \n                192    @classmethod\n193    def from_state_dict(cls, state_dict):\n194        obj = cls(**state_dict[\"config\"])\n195        for src, tgt in zip(\n196            [state_dict[\"weights\"], state_dict[\"grad\"]],\n197            [obj.layers, obj.grad],\n198        ):\n199            for k, v in src.items():\n200                tgt[k][:] = v\n201        return obj"
  },
  {
    "objectID": "blog/2024-06-15-lstm-from-scratch/index.html#activation-and-loss-functions",
    "href": "blog/2024-06-15-lstm-from-scratch/index.html#activation-and-loss-functions",
    "title": "Multi-Layer LSTM from Scratch using NumPy",
    "section": "Activation and Loss Functions",
    "text": "Activation and Loss Functions\nThe activation functions used in LSTM are the sigmoid, tanh (hyperbolic tangent), and softmax functions.\n\nSigmoid is used to compute the gates, which are values between 0 and 1 that control the flow of information.\n\ntanh function is used to compute the candidate memory state.\n\nSoftmax is used to compute the output probabilities.\n\nThe loss function used is the cross-entropy loss, which is suitable for classification tasks. Next token prediction is indeed a classification task where the model predicts the probability distribution over the vocabulary for the next token in the sequence.\n\n&gt; op.py\n\n\n\n        \n            \n            \n        \n            \n                \n                    #\n                \n                Sigmoid function\nThe sigmoid squashes the input to the range [0, 1].\n\nIf the flag grad is False, returns the sigmoid of x: $$\\sigma(x) = \\frac{1}{1 + e^{-x}}$$\nOtherwise, \\(x = \\sigma(z)\\) and the derivate \\(\\frac{\\partial \\sigma(z)}{\\partial z}\\) is returned:\n$$\\frac{\\partial \\sigma(z)}{\\partial z} = \\sigma(z) * (1 - \\sigma(z))= x(1-x)$$.\n\n\n            \n            \n                1import numpy as np\n2\n3\n4def sigmoid(x, grad=False):\n5    if not grad:\n6        return 1 / (1 + np.exp(-x))\n7    return x * (1 - x)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Hyperbolic tangent function\nThe tanh function squashes the input to the range [-1, 1]. It's defined as:\n$$\\tanh(x) = \\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}}$$\n\n            \n            \n                 8def tanh(x, grad=False):\n 9    if not grad:\n10        return np.tanh(x)\n11    return 1 - x**2\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Softmax function\nApplies the softmax function to the input array along the specified axis. Softmax converts\na vector of real numbers into a probability distribution. The logits are first exponentiated\nto make them positive and increase their separation. It's defined as:\n$$\\text{softmax}(x_i) = \\frac{e^{x_i}}{\\sum_{j} e^{x_j}}$$\n\n            \n            \n                12def softmax(x, axis):\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Subtracting the maximum value for numerical stability. Softmax is invariant to to a constant shift\n\n            \n            \n                13    exps = np.exp(x - np.max(x, axis=axis, keepdims=True))\n14    return exps / np.sum(exps, axis=axis, keepdims=True)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Cross-entropy loss function\nComputes the cross-entropy loss between the predicted and target distributions. The cross-entropy loss is defined as:\n$$H(y, p) = -\\sum_{i} y_i \\log(p_i)$$\n\nprediction: The predicted array of probabilities of shape (batch_size, num_classes).\ntarget: The target array of shape (batch_size,) containing the class indices.\n\n\n            \n            \n                15def cross_entropy(prediction, target, reduction=\"mean\"):\n16    eps = np.finfo(prediction.dtype).eps\n17    prediction = np.clip(prediction, eps, 1 - eps)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Take the negative log of the predicted probability of the target class\n\n            \n            \n                18    loss = -np.take_along_axis(\n19        np.log(prediction), target[..., np.newaxis], axis=-1\n20    )\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Aggregate the loss\n\n            \n            \n                21    if reduction == \"mean\":\n22        loss = loss.mean()\n23    elif reduction == \"sum\":\n24        loss = loss.sum()\n25    return loss"
  },
  {
    "objectID": "blog/2024-06-15-lstm-from-scratch/index.html#adamw",
    "href": "blog/2024-06-15-lstm-from-scratch/index.html#adamw",
    "title": "Multi-Layer LSTM from Scratch using NumPy",
    "section": "AdamW",
    "text": "AdamW\nAdamW is a variant of the Adam optimizer that decouples weight penalty from the optimization steps, where the weight penalty is applied directly to the gradients. Adam optimizer uses both the first and second moments of the gradients to adapt the learning rate tailored to each parameter. The benefit of Adam/AdamW is that it requires little tuning of hyperparameters compared to RMSprop and SGD. Weâ€™ll go over each step of the optimization in the implementation.\n\n&gt; optim.py\n\n\n\n        \n            \n            \n        \n            \n                \n                    #\n                \n                Import NumPy\n\n            \n            \n                1import numpy as np\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \n            \n            \n                2class AdamW:\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                AdamW Optimizer\nParameters:\n\nparams (dict): Dictionary referencing the model parameters\ngrads (dict): Dictionary referencing the gradients of the model parameters\nlr (float): Learning rate\nbetas (Tuple[float, float]): Coefficients used for computing running averages of gradient and its square\neps (float): Term added to the denominator to improve numerical stability\nweight_decay (float): Weight decay (L2 penalty) coefficient\namsgrad (bool): Whether to use the AMSGrad variant of the algorithm\n\n\n            \n            \n                 3    def __init__(\n 4        self,\n 5        params: dict,\n 6        grads: dict,\n 7        lr=0.001,\n 8        betas: tuple[float, float] = (0.9, 0.999),\n 9        eps: float = 1e-8,\n10        weight_decay: float = 1e-2,\n11        amsgrad: bool = False,\n12    ):\n13        self.params = params\n14        self.grads = grads\n15        self.lr = lr\n16        self.betas = betas\n17        self.eps = eps\n18        self.weight_decay = weight_decay\n19        self.amsgrad = amsgrad\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Counter for the number of iterations\n\n            \n            \n                20        self.n_iters = 0\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Initialize first moment vector (mean of gradients) for each parameter\n\n            \n            \n                21        self.m = {k: np.zeros_like(v) for k, v in params.items()}\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Initialize second moment vector (uncentered variance of gradients) for each parameter\n\n            \n            \n                22        self.v = {k: np.zeros_like(v) for k, v in params.items()}\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Initialize maximum of second moment vector for AMSGrad if needed\n\n            \n            \n                23        self.v_m = (\n24            {k: np.zeros_like(v) for k, v in params.items()}\n25            if amsgrad\n26            else None\n27        )\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Resets all gradients to zero. This is typically used before computing new\ngradients in the training loop.\n\n            \n            \n                28    def zero_grad(self):\n29        for v in self.grads.values():\n30            v[:] = 0\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Perform a single optimization step.\nUpdates the parameters of the model using the AdamW update rule, which\nincludes bias correction, optional AMSGrad, and weight decay.\n\n            \n            \n                31    def step(self):\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Increment the iteration counter\n\n            \n            \n                32        self.n_iters += 1\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Unpack the beta values\n\n            \n            \n                33        beta1, beta2 = self.betas\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Iterate over the parameters and their gradients\n\n            \n            \n                34        for (name, param), grad in zip(\n35            self.params.items(), self.grads.values()\n36        ):\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Update the first moment estimate:\n$$m_t = \\beta_1 \\cdot m_{t-1} + (1 - \\beta_1) \\cdot g_t$$\nwhere \\(\\beta_1\\) is the exponential decay rate for the first moment estimates,\nand \\(g_t\\) is the gradient at time step \\(t\\).  \n\\(m_{t}\\) is simply an exponential moving average (EMA) of the past gradients.\n\n            \n            \n                37            m_t = self.m[name] = (\n38                beta1 * self.m[name] + (1 - beta1) * grad\n39            )\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Update the second moment estimate:\n$$v_t = \\beta_2 \\cdot v_{t-1} + (1 - \\beta_2) \\cdot g_t^2$$\nwhere \\(\\beta_2\\) is the exponential decay rate for the second moment estimates.\n\n            \n            \n                40            v_t = self.v[name] = beta2 * self.v[name] + (\n41                1 - beta2\n42            ) * (grad**2)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Compute bias-corrected first moment estimate:\n$$\\hat{m}_t = \\frac{m_t}{1 - \\beta_1^t}$$\nWithout correction, the bias causes the algorithm to move very slowly at the beginning of training,\nas the moment estimates are underestimated. In the early iterations, \\(t\\) is small, so \\(\\beta_1^t\\) is close to 1,\nmaking \\(1 - \\beta_1^t\\) a small number. Dividing by this small number effectively increases the estimate.\n\n            \n            \n                43            m_t_hat = m_t / (1 - beta1**self.n_iters)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Compute bias-corrected second moment estimate:\n$$\\hat{v}_t = \\frac{v_t}{1 - \\beta_2^t}$$\n\n            \n            \n                44            v_t_hat = v_t / (1 - beta2**self.n_iters)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                AMSGrad update:\n$$\\hat{v}_t = \\max(\\hat{v}_t, v_{t-1})$$\nwhere \\(v_{t-1}\\) is the previous second moment estimate.\nThis ensures \\(v_t\\) is always non-decreasing, preventing the learning rate from growing too large.\n\n            \n            \n                45            if self.amsgrad:\n46                v_t_hat = self.v_m[name] = np.maximum(\n47                    self.v_m[name], v_t_hat\n48                )\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Adjusted gradient:\n$$\\hat{g} = \\frac{\\hat{m}_t}{\\sqrt{\\hat{v}_t} + \\epsilon}$$\nwhere \\(\\epsilon\\) is a small constant to avoid division by zero.  \n\\(\\frac{\\hat{m}_t}{\\sqrt{\\hat{v}_t}}\\) can be thought of as the signal-to-noise ratio of the gradient.\nI'll leave the intuition behind this to another blog post.\n\n            \n            \n                49            g_hat = m_t_hat / (np.sqrt(v_t_hat) + self.eps)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Add weight penalty to the update:\n$$\\text{update} = \\hat{g} + \\lambda \\cdot p$$\nwhere \\(\\lambda\\) is the weight_decay coefficient.\nThis is equivalent to adding the L2 penalty to the loss function, which penalizes large weights.\n\n            \n            \n                50            update = g_hat + self.weight_decay * param\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Update the parameters in the direction of the negative gradient, scaled by the learning rate:\n$$ p_t = p_{t-1} - \\eta \\cdot \\text{update}$$\nwhere \\(p_{t-1}\\) is the previous parameter value.\n\n            \n            \n                51            self.params[name] -= self.lr * update"
  },
  {
    "objectID": "blog/2024-06-15-lstm-from-scratch/index.html#data-utilities",
    "href": "blog/2024-06-15-lstm-from-scratch/index.html#data-utilities",
    "title": "Multi-Layer LSTM from Scratch using NumPy",
    "section": "Data Utilities",
    "text": "Data Utilities\nIn this section weâ€™ll implement the Dataset and Dataloader classes to handle the Shakespeare dataset. We follow the best practices of PyTorchâ€™s Dataset and DataLoader classes to make the implementation more modular and reusable.\n\nThe Dataset class implements the __getitem__ method, which returns a single sample from the dataset.\nThe DataLoader class will be used to sample mini-batches from the dataset, by calling the __getitem__ method of the Dataset.\n\n\n&gt; data.py\n\n\n\n        \n            \n            \n        \n            \n                \n                    #\n                \n                Import NumPy\n\n            \n            \n                1import numpy as np\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Dataset\nA dataset for next character prediction tasks.\nFor a sequence of characters \\([c_1, c_2, ..., c_n]\\) and a given sequence length \\(l\\),\nthis dataset creates input/target pairs of the form:\n\nInput \\(x_i\\):  \\([c_i, c_{i+1}, ..., c_{i+l-1}]\\)\nTarget \\(y_i\\): \\([c_{i+1}, c_{i+2}, ..., c_{i+l}]\\)\n\nwhere \\(i\\) ranges from 1 to \\(n-l\\).\nEach item in the dataset is a tuple \\((x_i, y_i)\\) where both \\(x_i\\) and \\(y_i\\) have length \\(l\\).\nThe task is to predict each character in \\(y_i\\) given the corresponding prefix in \\(x_i\\).\nFor example, given \\(x_i = [c_i, c_{i+1}, c_{i+2}]\\), the model would aim to predict:\n\n\\(c_{i+1}\\) given \\([c_i]\\)\n\\(c_{i+2}\\) given \\([c_i, c_{i+1}]\\)\n\\(c_{i+3}\\) given \\([c_i, c_{i+1}, c_{i+2}]\\)\n\n\n            \n            \n                2class NextCharDataset:\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \n            \n            \n                3    def __init__(self, data, seq_length):\n4        self.data = data.copy()\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                Create a sliding window view of the data\n\n            \n            \n                5        self.window_view = np.lib.stride_tricks.sliding_window_view(\n6            self.data, window_shape=seq_length + 1\n7        )\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \n            \n            \n                8    def __len__(self):\n9        return len(self.window_view)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \\(\\text{Input}_i\\):  \\([c_i, c_{i+1}, ..., c_{i+l-1}]\\)\n\\(\\text{Target}_i\\): \\([c_{i+1}, c_{i+2}, ..., c_{i+l}]\\)\n\n            \n            \n                10    def __getitem__(self, idx):\n11        x, y = self.window_view[idx, :-1], self.window_view[idx, 1:]\n12        return x, y\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                DataLoader\nA simple DataLoader to iterate over a dataset in batches.\n\n            \n            \n                13class DataLoader:\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \n            \n            \n                14    def __init__(\n15        self, dataset, batch_size, shuffle=False, drop_last=False\n16    ):\n17        self.dataset = dataset\n18        self.batch_size = batch_size\n19        self.shuffle = shuffle\n20        self.drop_last = drop_last\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                The __iter__ method returns an iterator that yields batches of data. It's mainly\nused in a for loop to iterate over the dataset. e.g.:\nfor inputs, targets in dataloader:\n    ...\n\n\n\n            \n            \n                21    def __iter__(self):\n22        indices = np.arange(len(self.dataset))\n23\n24        if self.shuffle:\n25            np.random.shuffle(indices)\n26\n27        if self.drop_last:\n28            remainder = len(self.dataset) % self.batch_size\n29            if remainder:\n30                indices = indices[:-remainder]\n31\n32        for i in range(0, len(indices), self.batch_size):\n33            batch_indices = indices[i : i + self.batch_size]\n34            batch = [self.dataset[j] for j in batch_indices]\n35            yield self.collate_fn(batch)\n\n            \n        \n    \n\n        \n            \n                \n                    #\n                \n                \n            \n            \n                36    def __len__(self):\n37        if self.drop_last:\n38            return len(self.dataset) // self.batch_size\n39        else:\n40            return np.ceil(\n41                len(self.dataset) / self.batch_size\n42            ).astype(int)\n43\n44    def collate_fn(self, batch):\n45        if isinstance(batch[0], (tuple, list)):\n46            return [np.array(samples) for samples in zip(*batch)]\n47        elif isinstance(batch[0], dict):\n48            return {\n49                key: np.array([d[key] for d in batch])\n50                for key in batch[0]\n51            }\n52        else:\n53            return np.array(batch)"
  },
  {
    "objectID": "blog/2024-06-15-lstm-from-scratch/index.html#training-on-shakespeare-dataset",
    "href": "blog/2024-06-15-lstm-from-scratch/index.html#training-on-shakespeare-dataset",
    "title": "Multi-Layer LSTM from Scratch using NumPy",
    "section": "Training on Shakespeare dataset",
    "text": "Training on Shakespeare dataset\nNow itâ€™s time to put everything together and train the model on the a dataset. Weâ€™ll use the Shakespeare dataset, which consists of a collection of Shakespeareâ€™s plays. The model will be trained to predict the next character in the sequence given a sequence of characters.\nAn important distinction to make between the text generation at training time and inference time is that at training time, we feed the ground truth characters to the model to predict the next character; This is called teacher forcing. At inference time, we feed the modelâ€™s prediction at time step \\(t\\) as the input at time step \\(t+1\\) to predict the next character.\n\nLoad\n\nimport numpy as np\nimport matplotlib.pylab as plt\n\nDownload the Shakespeare dataset which is a single text file from the following link: Shakespeare dataset\n\nwith open(\"shakespeare.txt\") as file:\n    data = file.read()\n\n\nprint(data[:200])\n\nFirst Citizen:\nBefore we proceed any further, hear me speak.\n\nAll:\nSpeak, speak.\n\nFirst Citizen:\nYou are all resolved rather to die than to famish?\n\nAll:\nResolved. resolved.\n\nFirst Citizen:\nFirst, you\n\n\n\n\nPreprocess\nWe need to convert the text data into numerical data. Using scikit-learnâ€™s LabelEncoder we can map each character to a unique integer. The same encoder will be used to inverse transform the predictions back to characters.\n\nfrom sklearn.preprocessing import LabelEncoder\n\nchar_data = np.array(list(data))\nencoder = LabelEncoder()\nindices_data = encoder.fit_transform(char_data)\n\n\nvocabulary = encoder.classes_\nvocabulary\n\narray(['\\n', ' ', '!', '$', '&', \"'\", ',', '-', '.', '3', ':', ';', '?',\n       'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n       'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n       'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n       'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'],\n      dtype='&lt;U1')\n\n\nAn example of the mapped data:\n\nindices_data[:200]\n\narray([18, 47, 56, 57, 58,  1, 15, 47, 58, 47, 64, 43, 52, 10,  0, 14, 43,\n       44, 53, 56, 43,  1, 61, 43,  1, 54, 56, 53, 41, 43, 43, 42,  1, 39,\n       52, 63,  1, 44, 59, 56, 58, 46, 43, 56,  6,  1, 46, 43, 39, 56,  1,\n       51, 43,  1, 57, 54, 43, 39, 49,  8,  0,  0, 13, 50, 50, 10,  0, 31,\n       54, 43, 39, 49,  6,  1, 57, 54, 43, 39, 49,  8,  0,  0, 18, 47, 56,\n       57, 58,  1, 15, 47, 58, 47, 64, 43, 52, 10,  0, 37, 53, 59,  1, 39,\n       56, 43,  1, 39, 50, 50,  1, 56, 43, 57, 53, 50, 60, 43, 42,  1, 56,\n       39, 58, 46, 43, 56,  1, 58, 53,  1, 42, 47, 43,  1, 58, 46, 39, 52,\n        1, 58, 53,  1, 44, 39, 51, 47, 57, 46, 12,  0,  0, 13, 50, 50, 10,\n        0, 30, 43, 57, 53, 50, 60, 43, 42,  8,  1, 56, 43, 57, 53, 50, 60,\n       43, 42,  8,  0,  0, 18, 47, 56, 57, 58,  1, 15, 47, 58, 47, 64, 43,\n       52, 10,  0, 18, 47, 56, 57, 58,  6,  1, 63, 53, 59])\n\n\n\n\nInitialize\nNow letâ€™s define the dataloader, the model and the optimizer. I used the following hyperparameters below, but feel free to experiment with different values.\n\nSEQUENCE_LENGTH = 128\nBATCH_SIZE = 32\nVOCAB_SIZE = len(vocabulary)\nTRAIN_SPLIT = 0.8\nLEARNING_RATE = 0.001\nSHUFFLE_TRAIN = True\n\nEMBED_SIZE = 256\nHIDDEN_SIZE = 512\nNUM_LAYERS = 2\nNUM_EPOCHS = 5\n\nDefine the train and test data loaders\n\nfrom data import NextCharDataset, DataLoader\n\ntrainset_size = int(len(indices_data) * TRAIN_SPLIT)\ntrain_data = indices_data[:trainset_size]\ntest_data = indices_data[trainset_size:]\n\ntrainset = NextCharDataset(train_data, SEQUENCE_LENGTH)\ntestset = NextCharDataset(test_data, SEQUENCE_LENGTH)\n\ntrainloader = DataLoader(trainset, batch_size=BATCH_SIZE, shuffle=SHUFFLE_TRAIN)\ntestloader = DataLoader(testset, batch_size=BATCH_SIZE, shuffle=False)\n\nDefine the model and optimizer\n\nfrom lstm import LSTMClassifier\nfrom optim import AdamW\n\nmodel = LSTMClassifier(EMBED_SIZE, HIDDEN_SIZE, VOCAB_SIZE, NUM_LAYERS)\noptimizer = AdamW(params=model.layers, grads=model.grad, lr=LEARNING_RATE)\n\n\n\nTraining loop\n\nfrom tqdm.auto import tqdm\nfrom collections import defaultdict\nfrom op import cross_entropy\n\nstate = None\ntrain_losses = defaultdict(list)\ntest_losses = defaultdict(list)\n\nfor epoch in tqdm(range(NUM_EPOCHS), desc=\"Epoch\"):\n    # training loop\n    for inputs, targets in (pbar := tqdm(trainloader, leave=False)):\n        if SHUFFLE_TRAIN:\n            state = None\n        probabilities, state, activations = model.forward(inputs, state)\n\n        # cross entropy loss\n        loss = cross_entropy(probabilities, targets)\n        # accuracy\n        accuracy = np.mean(np.argmax(probabilities, axis=-1) == targets)\n\n        # loss gradient w.r.t logits (before softmax)\n        gradient = np.copy(probabilities)\n        # Subtract 1 from the probabilities of the true classes\n        # Since the gradient is p_i - y_i\n        gradient[np.arange(targets.shape[0])[:, None], np.arange(targets.shape[1]), targets] -= 1\n        # Subtract 1 from the probabilities of the true classes\n        gradient /= gradient.shape[0]\n\n        # backpropagate and update\n        optimizer.zero_grad()\n        model.backward(gradient, activations)\n        optimizer.step()\n\n        # log\n        pbar.set_postfix({\"loss\": f\"{loss:.5f}\", \"accuracy\": f\"{accuracy*100:.2f}\"})\n        train_losses[epoch].append(loss)\n\n    # testing loop\n    loss_sum = 0\n    accuracy_sum = 0\n    for iter, (inputs, targets) in (pbar := tqdm(enumerate(testloader), leave=False)):\n        probabilities, state, _ = model.forward(\n            inputs, state=None, teacher_forcing=False\n        )\n        loss = cross_entropy(probabilities, targets)\n        accuracy = np.mean(np.argmax(probabilities, axis=-1) == targets)\n\n        loss_sum += loss\n        accuracy_sum += accuracy\n        pbar.set_postfix(\n            {\n                \"loss\": f\"{loss_sum / (iter + 1):.5f}\",\n                \"accuracy\": f\"{accuracy_sum / (iter + 1)*100:.2f}\",\n            }\n        )\n        test_losses[epoch].append(loss)\n\nFor checkpointing, we can save the model to disk:\n\nckpt = model.state_dict\nnp.save(\"checkpoint.npy\", ckpt)\n\nTo reload from the checkpoint, use the from_state_dict method:\n\nstate_dict = np.load(\"checkpoint.npy\", allow_pickle=True).item()\nmodel = LSTMClassifier.from_state_dict(state_dict)\n\nstate_dict.keys()\n\ndict_keys(['config', 'weights', 'grad'])\n\n\n\n\nGenerating text\nAt inference time, we feed the model a prefix text and let it generate the next characters. We can control the number of characters to generate by setting the generate_length parameter in forward. I used greedy decoding to generate the text, but there are other methods like beam search and Top-K sampling.\n\ndef generate(model, prefix: str, length: int):\n    inputs = np.array(list(prefix))\n    inputs = encoder.transform(inputs)\n    inputs = inputs[np.newaxis]\n    state = None\n\n    probabilities, state, _ = model.forward(\n        inputs, state, teacher_forcing=False, generation_length=length\n    )\n    tokens = np.argmax(probabilities[0, len(prefix) - 1 :], axis=-1)\n\n    output = prefix + \"\".join(encoder.inverse_transform(tokens))\n    return output\n\n\nprint(generate(model, prefix=\"I will\", length=400))\n\nI will rest blood that bear blood at all,\nAnd stay the king to the consulships?\n\nMENENIUS:\nNay, then he will stay the king to the cause of my son's exile is banished.\n\nROMEO:\nAnd stay the common people: there is no need, that I may call thee back.\n\nNORTHUMBERLAND:\nHere comes the county strict ready to give me leave to see him as he fall be thine, my lord.\n\nKING RICHARD II:\nNorfolk, throw down the coronat"
  },
  {
    "objectID": "test/index.html",
    "href": "test/index.html",
    "title": "Ayo?",
    "section": "",
    "text": "import numpy as np"
  },
  {
    "objectID": "publication/2018-01-03-protein-design/index.html",
    "href": "publication/2018-01-03-protein-design/index.html",
    "title": "Protein design using native secondary sub-structures and solvent accessibility",
    "section": "",
    "text": "According to structure-dependent function of proteins, two main challenging problems called Protein Structure Prediction (PSP) and Inverse Protein Folding (IPF) are investigated. In spite of IPF essential applications, it has not been studied as much as PSP problem. In fact, the ultimate goal of IPF problem or protein design is to create proteins with enhanced properties or even novel functions. One of the major computational challenges in protein design is large protein sequence space, namely searching through all plausible sequences is impossible. In our previous research, we introduced a genetic algorithm called GAPSSIF for designing protein secondary structure. This algorithm benefits from evolutionary information obtained by solved protein structures in PDB. Therefore, we constructed a repository of protein secondary sub-structures to accelerate convergence of the algorithm. The secondary structures of designed sequences by GAPSSIF are comparable with those obtained by Evolver and EvoDesign. In this paper, we modify GAPSSIF so it considers solvent accessibility. Therefore, the simple fitness function of GAPSSIF is improved by a multi-featured one to search through the sequence space more precisely."
  },
  {
    "objectID": "publication/2018-01-03-protein-design/index.html#abstract",
    "href": "publication/2018-01-03-protein-design/index.html#abstract",
    "title": "Protein design using native secondary sub-structures and solvent accessibility",
    "section": "",
    "text": "According to structure-dependent function of proteins, two main challenging problems called Protein Structure Prediction (PSP) and Inverse Protein Folding (IPF) are investigated. In spite of IPF essential applications, it has not been studied as much as PSP problem. In fact, the ultimate goal of IPF problem or protein design is to create proteins with enhanced properties or even novel functions. One of the major computational challenges in protein design is large protein sequence space, namely searching through all plausible sequences is impossible. In our previous research, we introduced a genetic algorithm called GAPSSIF for designing protein secondary structure. This algorithm benefits from evolutionary information obtained by solved protein structures in PDB. Therefore, we constructed a repository of protein secondary sub-structures to accelerate convergence of the algorithm. The secondary structures of designed sequences by GAPSSIF are comparable with those obtained by Evolver and EvoDesign. In this paper, we modify GAPSSIF so it considers solvent accessibility. Therefore, the simple fitness function of GAPSSIF is improved by a multi-featured one to search through the sequence space more precisely."
  },
  {
    "objectID": "publication/index.html",
    "href": "publication/index.html",
    "title": "Publications",
    "section": "",
    "text": "Tractable large-scale deep reinforcement learning\n\n\nThis work presents a reinforcement learning framework for road extraction from satellite images, offering reduced computational costs and improved stability through novel techniques and self-supervised loss\n\n\n\nReinforcement Learning\n\n\nComputer Vision\n\n\nSattelite Imagery\n\n\n\n\n\n\nJul 1, 2023\n\n\nNima Sarang, Charalambos Poullis\n\n\n\n\n\n\n\nProtein design using native secondary sub-structures and solvent accessibility\n\n\nAdvancing protein design through an improved genetic algorithm. This work builds on GAPSSIF, adding solvent accessibility to enhance sequence space exploration\n\n\n\nResearch\n\n\nProtein Design\n\n\nGenetic Algorithm\n\n\nSolvent Accessibility\n\n\n\n\n\n\nJan 3, 2018\n\n\nFatemeh Zare-Mirakabad, Marziyeh Movahedi, Nima Sarang, S. Shahriar Arab\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "project/2019-06-12-dc-gan/index.html",
    "href": "project/2019-06-12-dc-gan/index.html",
    "title": "DCGAN on MNIST",
    "section": "",
    "text": "A keras implementation of a custom Deep Convolutional Generative Adversarial Networks (DCGAN) on MNIST dataset. The code is based on the Francois Cholletâ€™s Deep Learning with Python, page 308.\nDCGAN is an extension of the GAN architecture, where the generator and discriminator are deep convolutional networks. The discriminator that takes an image as input and outputs a single scalar value representing the probability that the input image is real (as opposed to fake). The generator takes a random vector as input and decodes it into a synthetic image, and is trained to generate images that the discriminator identifies as real.\nThe code is available on my GitHub.\n\nWhat worked\n\nUsing dropout in the discriminator\n\nAdding noise to the labels\n\nUsing strided convolutions\n\nNormalizing the data to \\([-1, 1]\\)\nRMSprop optimizer\n\n\n\nWhat didnâ€™t work\n\nUsing high learning rates (&gt;1e-3)\nI initially normalized the data between 0 and 1, but since I was using â€œtanhâ€ as the last layer of the generatorâ€™s output, it made the convergence a lot harder\nConstructing separate batches for real and fake images\nTraining the discriminator with more steps than the generator\nUsing SGD optimizer\n\n\n\nResults\nThis is the first 5000 iterations of the training history. The random vectors are fixed at the beginning of the training. As the training progresses, the generator learns to generate more realistic images."
  },
  {
    "objectID": "project/2017-09-17-d3-force-graph-bio-networks/index.html",
    "href": "project/2017-09-17-d3-force-graph-bio-networks/index.html",
    "title": "D3 Force Layout - Biological Networks",
    "section": "",
    "text": "While working as a research assistant at the Computational Biology Research Center at the Amirkabir University of Technology, I was tasked with implmenting an algorithm for Identification of large disjoint motifs in biological networks. We soon realized we needed a visualization tool to help us better understand the networks we were working with, and the motifs that were identified. This was when I stumbled on the D3.js library, and decided to use its force layout for interactive visualization. The tool below is based on the countless examples and tutrials I found, which Iâ€™ve lost track of, and should give a glimpse of the power of D3.js.\nThis example is a visualization of protein-protein interaction network. Its main features are:\nThe source code can be found here. The visualization code is in the output folder."
  },
  {
    "objectID": "project/2017-09-17-d3-force-graph-bio-networks/index.html#network-details",
    "href": "project/2017-09-17-d3-force-graph-bio-networks/index.html#network-details",
    "title": "D3 Force Layout - Biological Networks",
    "section": "Network Details",
    "text": "Network Details\nOrder: \nSize: \nComponents:"
  },
  {
    "objectID": "project/2017-09-17-d3-force-graph-bio-networks/index.html#pattern-details",
    "href": "project/2017-09-17-d3-force-graph-bio-networks/index.html#pattern-details",
    "title": "D3 Force Layout - Biological Networks",
    "section": "Pattern Details",
    "text": "Pattern Details\nOrder: \nSize: \nFrequency:"
  },
  {
    "objectID": "project/2017-09-17-d3-force-graph-bio-networks/index.html#settings",
    "href": "project/2017-09-17-d3-force-graph-bio-networks/index.html#settings",
    "title": "D3 Force Layout - Biological Networks",
    "section": "Settings",
    "text": "Settings\n\nNode Charge  \n\n\nLink Strength  \n\n\nNode Radius  \n\n\nLink Width  \n\n\nVelocity Decay  \n\n\nCenter Gravity  \n\n   Force Static   FishEye Distortion Zoom Function Pin on Drop"
  },
  {
    "objectID": "project/2017-09-17-d3-force-graph-bio-networks/index.html#infoTitle",
    "href": "project/2017-09-17-d3-force-graph-bio-networks/index.html#infoTitle",
    "title": "D3 Force Layout - Biological Networks",
    "section": "About",
    "text": "About"
  }
]